Analise de complexidade de funções do sistema

Autores: Kaique Bahmad, Augusto de Morais, Marcos Antonio, Ruan Pablo
================================================================================


1) Gerar novas cobrancas e atualizar plano
@Transactional
public void gerarNovasCobrancasEAtualizarPlanoUsuario(LocalDateTime now) {
    log.info("Iniciando geração de novas cobranças em {}", now);
    Pageable pageRequest = PageRequest.of(0, batchSize);
    Page<PlanoCobranca> page;
    LocalDate localDateNow = now.toLocalDate();
    do {
        page = planoCobrancaRepository.findPagasComProximaNaoGerada(localDateNow, pageRequest);
        log.info("Processando {} cobranças pagas com próxima não gerada", page.getNumberOfElements());

        for (PlanoCobranca cobranca: page.getContent()) {
            planoUsuarioService.gerarProximaCobranca(cobranca);
        }

        pageRequest = pageRequest.next();
    } while (!page.isLast());
    log.info("Finalizada geração de novas cobranças");
}

ANÁLISE DE COMPLEXIDADE:
- Complexidade de Tempo: O(n)
  Onde n é o número total de cobranças a serem processadas. A função itera sobre todas
  as páginas de resultados (do-while) e para cada página processa todos os elementos (for).
  O número de iterações do loop externo é n/batchSize e o loop interno processa batchSize
  elementos, resultando em O(n) total.

2) Processar Inadimplencias
@Transactional
public void processarInadimplencias(LocalDateTime now) {
    log.info("Iniciando processamento de inadimplências em {}", now);
    Pageable pageRequest = PageRequest.of(0, batchSize);
    Page<PlanoCobranca> page;
    LocalDate localDateNow = now.toLocalDate();
    do {
        page = planoCobrancaRepository.findVencidasNaoProcessadas(localDateNow, pageRequest);
        log.info("Processando {} cobranças vencidas não processadas", page.getNumberOfElements());

        for (PlanoCobranca cobranca: page.getContent()) {
            planoUsuarioService.processarInadimplencia(cobranca);
        }

        pageRequest = pageRequest.next();
    } while (!page.isLast());
    log.info("Finalizado processamento de inadimplências");
}

ANÁLISE DE COMPLEXIDADE:
- Complexidade de Tempo: O(n)
  Onde n é o número total de cobranças vencidas a serem processadas. Similar à função anterior,
  utiliza paginação para processar os registros em lotes. O loop externo itera sobre as páginas
  (n/batchSize iterações) e o loop interno processa cada cobrança da página (batchSize elementos),
  resultando em complexidade linear O(n).

3) Função utilitaria para ver se usuario tem uma entre algumas roles
public static boolean hasAnyRole(Role... roles) {
    Collection<? extends GrantedAuthority> authorities = SecurityContextHolder.getContext()
            .getAuthentication()
            .getAuthorities();

    for (Role role : roles) {
        if (authorities.contains(new SimpleGrantedAuthority("ROLE_" + role.name()))) {
            return true;
        }
    }
    return false;
}

ANÁLISE DE COMPLEXIDADE:
- Complexidade de Tempo: O(n * m)
  Onde n é o número de roles fornecidos como parâmetro e m é o número de authorities que
  o usuário possui. Para cada role (n iterações), é feita uma verificação na coleção de
  authorities usando o método contains(), que tem complexidade O(m) para uma Collection
  genérica. No melhor caso, a função retorna true na primeira iteração: O(m). No pior caso,
  verifica todas as roles: O(n * m).

4) Função utilitaria que verificar se usuario tem todas as roles dentro de uma lista de roles
public static boolean hasAllRoles(Role... roles) {
    Collection<? extends GrantedAuthority> authorities = SecurityContextHolder.getContext()
            .getAuthentication()
            .getAuthorities();

    for (Role role : roles) {
        if (!authorities.contains(new SimpleGrantedAuthority("ROLE_" + role.name()))) {
            return false;
        }
    }
    return true;
}

ANÁLISE DE COMPLEXIDADE:
- Complexidade de Tempo: O(n * m)
  Onde n é o número de roles fornecidos como parâmetro e m é o número de authorities do
  usuário. A estrutura é similar à função hasAnyRole, mas com lógica inversa. Para cada
  role (n iterações), verifica se ela existe na coleção de authorities usando contains(),
  que tem complexidade O(m). No melhor caso, encontra uma role ausente logo na primeira
  iteração: O(m). No pior caso, todas as roles estão presentes: O(n * m).

5) Retorno de Cobranças do usuario mapeadas em DTO
@GetMapping
@PreAuthorize("hasAnyRole('CUSTOMER')")
public ResponseEntity<Page<PlanoCobrancaCustomerResponse>> getCustomerCobrancas(
        Pageable pageable) throws JsonProcessingException {
    Page<PlanoCobrancaCustomerResponse> cobrancas = planoCobrancaService.findCobrancasByUsuarioId(SecurityUtils.getCurrentUserId(), pageable)
            .map(PlanoCobrancaCustomerResponse::fromEntity);
    return ResponseEntity.ok(cobrancas);
}

ANÁLISE DE COMPLEXIDADE:
- Complexidade de Tempo: O(p + q)
  Onde p é o tamanho da página retornada pelo repository (número de elementos) e q é a
  complexidade da consulta ao banco de dados (findCobrancasByUsuarioId). A operação map()
  itera sobre todos os elementos da página, aplicando a transformação fromEntity() em
  cada um, resultando em O(p). A complexidade total depende da implementação do repository,
  mas geralmente é O(q + p), onde q pode envolver índices de banco de dados para otimizar
  a busca.

